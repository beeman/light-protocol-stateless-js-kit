/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  assertAccountExists,
  assertAccountsExist,
  type Codec,
  combineCodec,
  type Decoder,
  decodeAccount,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
  transformEncoder,
} from '@solana/kit'
import {
  getInstructionDataInvokeCpiDecoder,
  getInstructionDataInvokeCpiEncoder,
  type InstructionDataInvokeCpi,
  type InstructionDataInvokeCpiArgs,
} from '../types/index.ts'

export const CPI_CONTEXT_ACCOUNT_DISCRIMINATOR = new Uint8Array([22, 20, 149, 218, 74, 204, 128, 166])

export function getCpiContextAccountDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CPI_CONTEXT_ACCOUNT_DISCRIMINATOR)
}

/**
 * Collects instruction data without executing a compressed transaction.
 * Signer checks are performed on instruction data.
 * Collected instruction data is combined with the instruction data of the executing cpi,
 * and executed as a single transaction.
 * This enables to use input compressed accounts that are owned by multiple programs,
 * with one zero-knowledge proof.
 */
export type CpiContextAccount = {
  discriminator: ReadonlyUint8Array
  feePayer: Address
  associatedMerkleTree: Address
  context: Array<InstructionDataInvokeCpi>
}

export type CpiContextAccountArgs = {
  feePayer: Address
  associatedMerkleTree: Address
  context: Array<InstructionDataInvokeCpiArgs>
}

/** Gets the encoder for {@link CpiContextAccountArgs} account data. */
export function getCpiContextAccountEncoder(): Encoder<CpiContextAccountArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['feePayer', getAddressEncoder()],
      ['associatedMerkleTree', getAddressEncoder()],
      ['context', getArrayEncoder(getInstructionDataInvokeCpiEncoder())],
    ]),
    (value) => ({ ...value, discriminator: CPI_CONTEXT_ACCOUNT_DISCRIMINATOR }),
  )
}

/** Gets the decoder for {@link CpiContextAccount} account data. */
export function getCpiContextAccountDecoder(): Decoder<CpiContextAccount> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['feePayer', getAddressDecoder()],
    ['associatedMerkleTree', getAddressDecoder()],
    ['context', getArrayDecoder(getInstructionDataInvokeCpiDecoder())],
  ])
}

/** Gets the codec for {@link CpiContextAccount} account data. */
export function getCpiContextAccountCodec(): Codec<CpiContextAccountArgs, CpiContextAccount> {
  return combineCodec(getCpiContextAccountEncoder(), getCpiContextAccountDecoder())
}

export function decodeCpiContextAccount<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<CpiContextAccount, TAddress>
export function decodeCpiContextAccount<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<CpiContextAccount, TAddress>
export function decodeCpiContextAccount<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<CpiContextAccount, TAddress> | MaybeAccount<CpiContextAccount, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getCpiContextAccountDecoder())
}

export async function fetchCpiContextAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<CpiContextAccount, TAddress>> {
  const maybeAccount = await fetchMaybeCpiContextAccount(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeCpiContextAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<CpiContextAccount, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeCpiContextAccount(maybeAccount)
}

export async function fetchAllCpiContextAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<CpiContextAccount>[]> {
  const maybeAccounts = await fetchAllMaybeCpiContextAccount(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeCpiContextAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<CpiContextAccount>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map((maybeAccount) => decodeCpiContextAccount(maybeAccount))
}
