/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Address,
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from '@solana/kit'
import {
  type ParsedInitCpiContextAccountInstruction,
  type ParsedInvokeCpiInstruction,
  type ParsedInvokeCpiWithReadOnlyInstruction,
  type ParsedInvokeInstruction,
  type ParsedStubIdlBuildInstruction,
  parseInitCpiContextAccountInstruction,
  parseInvokeCpiInstruction,
  parseInvokeCpiWithReadOnlyInstruction,
  parseInvokeInstruction,
  parseStubIdlBuildInstruction,
} from '../instructions/index.ts'

export const LIGHT_SYSTEM_PROGRAM_PROGRAM_ADDRESS = '' as Address<''>

export enum LightSystemProgramAccount {
  CpiContextAccount,
}

export function identifyLightSystemProgramAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LightSystemProgramAccount {
  const data = 'data' in account ? account.data : account
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([22, 20, 149, 218, 74, 204, 128, 166])),
      0,
    )
  ) {
    return LightSystemProgramAccount.CpiContextAccount
  }
  throw new Error('The provided account could not be identified as a lightSystemProgram account.')
}

export enum LightSystemProgramInstruction {
  InitCpiContextAccount,
  Invoke,
  InvokeCpi,
  InvokeCpiWithReadOnly,
  StubIdlBuild,
}

export function identifyLightSystemProgramInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): LightSystemProgramInstruction {
  const data = 'data' in instruction ? instruction.data : instruction
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([233, 112, 71, 66, 121, 33, 178, 188])),
      0,
    )
  ) {
    return LightSystemProgramInstruction.InitCpiContextAccount
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 16, 169, 7, 21, 202, 242, 25])),
      0,
    )
  ) {
    return LightSystemProgramInstruction.Invoke
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([49, 212, 191, 129, 39, 194, 43, 196])),
      0,
    )
  ) {
    return LightSystemProgramInstruction.InvokeCpi
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([86, 47, 163, 166, 21, 223, 92, 8])),
      0,
    )
  ) {
    return LightSystemProgramInstruction.InvokeCpiWithReadOnly
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([118, 99, 238, 243, 8, 167, 251, 168])),
      0,
    )
  ) {
    return LightSystemProgramInstruction.StubIdlBuild
  }
  throw new Error('The provided instruction could not be identified as a lightSystemProgram instruction.')
}

export type ParsedLightSystemProgramInstruction<TProgram extends string = ''> =
  | ({
      instructionType: LightSystemProgramInstruction.InitCpiContextAccount
    } & ParsedInitCpiContextAccountInstruction<TProgram>)
  | ({
      instructionType: LightSystemProgramInstruction.Invoke
    } & ParsedInvokeInstruction<TProgram>)
  | ({
      instructionType: LightSystemProgramInstruction.InvokeCpi
    } & ParsedInvokeCpiInstruction<TProgram>)
  | ({
      instructionType: LightSystemProgramInstruction.InvokeCpiWithReadOnly
    } & ParsedInvokeCpiWithReadOnlyInstruction<TProgram>)
  | ({
      instructionType: LightSystemProgramInstruction.StubIdlBuild
    } & ParsedStubIdlBuildInstruction<TProgram>)

export function parseLightSystemProgramInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedLightSystemProgramInstruction<TProgram> {
  const instructionType = identifyLightSystemProgramInstruction(instruction)
  switch (instructionType) {
    case LightSystemProgramInstruction.InitCpiContextAccount: {
      assertIsInstructionWithAccounts(instruction)
      return {
        instructionType: LightSystemProgramInstruction.InitCpiContextAccount,
        ...parseInitCpiContextAccountInstruction(instruction),
      }
    }
    case LightSystemProgramInstruction.Invoke: {
      assertIsInstructionWithAccounts(instruction)
      return {
        instructionType: LightSystemProgramInstruction.Invoke,
        ...parseInvokeInstruction(instruction),
      }
    }
    case LightSystemProgramInstruction.InvokeCpi: {
      assertIsInstructionWithAccounts(instruction)
      return {
        instructionType: LightSystemProgramInstruction.InvokeCpi,
        ...parseInvokeCpiInstruction(instruction),
      }
    }
    case LightSystemProgramInstruction.InvokeCpiWithReadOnly: {
      assertIsInstructionWithAccounts(instruction)
      return {
        instructionType: LightSystemProgramInstruction.InvokeCpiWithReadOnly,
        ...parseInvokeCpiWithReadOnlyInstruction(instruction),
      }
    }
    case LightSystemProgramInstruction.StubIdlBuild: {
      assertIsInstructionWithAccounts(instruction)
      return {
        instructionType: LightSystemProgramInstruction.StubIdlBuild,
        ...parseStubIdlBuildInstruction(instruction),
      }
    }
    default:
      throw new Error(`Unrecognized instruction type: ${instructionType as string}`)
  }
}
